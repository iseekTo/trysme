<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on wm&#39;s blog</title>
    <link>https://iseekto.github.io/trysme/posts/</link>
    <description>Recent content in Posts on wm&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 17 Jan 2020 16:21:40 +0800</lastBuildDate>
    
	<atom:link href="https://iseekto.github.io/trysme/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Ts代码片段</title>
      <link>https://iseekto.github.io/trysme/2020/ts%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</link>
      <pubDate>Fri, 17 Jan 2020 16:21:40 +0800</pubDate>
      
      <guid>https://iseekto.github.io/trysme/2020/ts%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</guid>
      <description>interface定义函数 interface User { name: string age: number } // 定义单个函数，用type定义是个不错的选择 type UserFunc = (user: User) =&amp;gt; string const getUserInfo: UserFunc = (user) =&amp;gt; { return `name: ${user.name}，age: ${user.age}` } getUserInfo({ name: &#39;ff&#39;, age: 23 })  typeof 探查某个dom/关键字的类型 // 想知道某个dom，关键字(setTimeout)的类型是什么，可用typeof let div = document.createElement(&#39;div&#39;); // HTMLDivElement type divType = typeof div let timer = setTimeout(() =&amp;gt; console.log(&#39;st&#39;), 2) // NodeJS.Timeout type timerType = typeof timer  ts高级类型 // 剔除某个键 Omit let person = { name: &#39;name&#39;, hoppy: [&#39;eat&#39;, &#39;sleep&#39;] } type user = Omit&amp;lt;typeof person, &#39;name&#39;&amp;gt;   持续更新中&amp;hellip;</description>
    </item>
    
    <item>
      <title>常见需求</title>
      <link>https://iseekto.github.io/trysme/2020/%E5%B8%B8%E8%A7%81%E9%9C%80%E6%B1%82/</link>
      <pubDate>Fri, 17 Jan 2020 16:12:32 +0800</pubDate>
      
      <guid>https://iseekto.github.io/trysme/2020/%E5%B8%B8%E8%A7%81%E9%9C%80%E6%B1%82/</guid>
      <description> 生成二维码：使用 QRCode import QRCode from &#39;qrcode&#39;; const opt = {} const url = window.location.url try { console.log(await QRCode.toDataURL(url, opt)) } catch(err) { console.error(err) }  -- 生成图片：使用html2canvas import html2canvas from &#39;html2canvas&#39;; html2canvas(document.body).then(function(canvas) { document.body.appendChild(canvas); });  后续问题：  生成的有base64，但img区域空白 解决方案：  截图产生空白是因为容器高度设置的问题，设置windowHeight的高度等于页面包含滚动条的高度即可获取滚动条中的内容。这一条就可以解决空白的问题。 设置width、height属性的原因是，我们在页面中截图显示的区域宽度和高度是固定的，就是当前屏幕的可见区域。 设置x、y坐标的原因是由于页面在有滚动条的时候，需要指定截图的起始位置。本项目中x轴方向不存在滚动条，所以设置为零；y方向有滚动条，所以需要获取一下当前方向的滚动坐标。 一般网页中会有图片，图片中有链接地址时，设置useCORS属性可保证图片的加载。   </description>
    </item>
    
    <item>
      <title>Js面试</title>
      <link>https://iseekto.github.io/trysme/2020/js%E9%9D%A2%E8%AF%95/</link>
      <pubDate>Fri, 17 Jan 2020 15:33:22 +0800</pubDate>
      
      <guid>https://iseekto.github.io/trysme/2020/js%E9%9D%A2%E8%AF%95/</guid>
      <description> 一、铺平数组 给定原数组：let moreArr = [1, 2, [3, 4], [33, [442]], 5];
1、moreArr = [...moreArr] 2、moreArr = moreArr.flat(Infinity) 3、while(moreArr.some(Array.isArray)) { moreArr = [].concat(...moreArr) } 4、let flatArr = []; function flats(arr = []) { arr.forEach(v =&amp;gt; { if (Array.isArray(v)) { flats(v) } else { flatArr.push(v) } }) }  </description>
    </item>
    
    <item>
      <title>Hugo简单实用</title>
      <link>https://iseekto.github.io/trysme/2020/hugo%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8/</link>
      <pubDate>Wed, 15 Jan 2020 23:37:32 +0800</pubDate>
      
      <guid>https://iseekto.github.io/trysme/2020/hugo%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8/</guid>
      <description>注：使用 hugo new posts/...md 之后，需要将 draft: true 这一行删掉。
文章写完后，且绑定了github域名了，
我们接着操作 hugo 他会在根目录下的 public 文件夹生成我们改动之后的代码
然后就是一波 git add -A, git commit ....
最后就可以在你的github上看效果吧！</description>
    </item>
    
    <item>
      <title>React生命周期执行顺序</title>
      <link>https://iseekto.github.io/trysme/2020/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Wed, 15 Jan 2020 23:05:35 +0800</pubDate>
      
      <guid>https://iseekto.github.io/trysme/2020/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid>
      <description> React生命周期执行顺序： ###################	渲染过程 ############### #constructor: ES6构造函数. 1.定义它是为了初始化state，这样我们可以在组件生命周期任何函数中访问state 1.其次是为了绑定成员函数的this环境、 #render：组件中最重要的函数，渲染DOM。 1.它返回一个JSX描述的结构，最终由react来操作渲染过程 2.如果组件的作用不是为了渲染页面，无东西可画，我们可以返回一个null或者false 3.不可再render中使用this.setState，因为一个纯函数不应该引起状态的改变。 #componentWillMount: 组件渲染前，将要装载时。 1.它执行完毕会走render函数 2.建议数据渲染不要放在这个函数里 3.一般都在里放loading，改变引用title等。 4.它可以在浏览器和服务器端被调用。 #componentDidMount: 组件挂载时 1.这里我们可以拿到DOM节点，动态赋予DOM事件 2.可以请求数据接口 3.它只能在浏览器端被调用，因为DOM已经挂载 4.可结合其他UI库执行代码。 ################## 更新过程 ################## 组件被挂载到DOM树上之后，当props或者state被更改的时候会依次执行以下生命周期函数 #componentWillReceiveProps 1.只要是父组件里的render函数被调用，在render函数里面#【被渲染的子组件也会经历更新过程】#； 不管父传给子组件的props有没有改变，都会触发子组件的componentWillReceiveProps函数 2.注意：this.setState()函数在更新的过程中不会触发这个函数； 因为它是根据props值，也就是参数nextProps来计算出是不是要更新内部state状态 3.触发之后会更新子组件的render函数 #shouldComponentUpdate: 性能优化利器-决定一个组件什么时候不需要渲染。 1.在更新过程中，react会首先调用shouldComponentUpdate函数，如果他返回true，继续更新 接下来调用render 反之，停止更新，也就不会引发后续的渲染。 2.通过this.setState()函数引发更新过程，而不是立即更新组件的state值，在执行到本周期函数时，this.state依 然是this.setState()函数执行前的值，我们要做的就是在nextProps, this.props, nextState, this.state中做对比。 #componentWillUpdate：组件更新前 1.如果shouldComponentUpdate函数返回true，react接下来就会调用组件的componentWillUpdate, render和componentDidUpdate函数。 2.使用React做服务端渲染时(SSR), 基本不会经历更新过程，因为服务端之产出一个HTML字符串。 ################## 卸载过程 ################## #componentWillUnMount: 组件卸载时 1.本周期函数与componentDidMount周期函数有关，用于移除DOM节点 2.清除定时器。 React生命周期走势大致是： constructor-&amp;gt;componentWillMount-&amp;gt;render-&amp;gt;componentDidMount-&amp;gt;!props更新调用-&amp;gt;(componentWillReceiveProps -&amp;gt; render) -&amp;gt;(shouldComponentUpdate ? true -&amp;gt; componentWillUpdate -&amp;gt; render -&amp;gt; componentDidUpdate : componentWillUnMount: 不会打印 默认执行了)  </description>
    </item>
    
    <item>
      <title>Makedown</title>
      <link>https://iseekto.github.io/trysme/2020/makedown/</link>
      <pubDate>Wed, 15 Jan 2020 18:28:14 +0800</pubDate>
      
      <guid>https://iseekto.github.io/trysme/2020/makedown/</guid>
      <description>Table of Contents  1212 22 333   第一项：  第一项嵌套的第一个元素 第一项嵌套的第二个元素  深入嵌套   第二项：  第二项嵌套的第一个元素  深入嵌套&amp;ndash;二  第二项嵌套的第二个元素   cd rn项目 react-native run-ios 之后yarn start 打开手机模拟器即可显示。 新增代码高亮效果 - let bs = undefined; + bs = 100  解读React Native https://www.jianshu.com/p/ff20064f7a7f
更换RN应用程序图标 在Xcode里双击项目工程 -&amp;gt; general-&amp;gt; App Icons Source将合成好的图片拉到 Images-1.xcassets下 重新启动 成功， 相关连接 https://www.jianshu.com/p/56562e5a9396 HTML block below  This blockquote will change based on the HTML settings above.</description>
    </item>
    
    <item>
      <title>iOS兼容问题</title>
      <link>https://iseekto.github.io/trysme/2020/ios%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 15 Jan 2020 18:26:38 +0800</pubDate>
      
      <guid>https://iseekto.github.io/trysme/2020/ios%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</guid>
      <description>前置条件：在不使用第三方封装好的ui库，比如跨端框架Taro。
 input兼容问题 1、掉起输入框英文键盘，第一个字母为大写的问题
&amp;lt;input type=&amp;quot;text&amp;quot; autocapitalize=&amp;quot;off&amp;quot; /&amp;gt; 
2、在靠近底部触发input输入框，输入完成后，页面底部留白问题
注册blur事件及定时器变量方便下一个focus时清除此使用，使用document.scrollIntoView()，然后在加上window.scrollTo(0, document.body.scrollHeight) 来重置高度
3、获取焦点时，光标错位
加上如下css样式user-select: text 如下js input.target.scrollIntoView(true)
4、输入框获取焦点时，页面输入框被覆盖，定位的元素位置错乱
可能性：当input位于fixed底部时，输入法弹出后，fixed会失效，页面的定位元素也会乱
方案一：使用原生 API scrollIntoView(true) focus时，定时器 setTimeout(() =&amp;gt; input.target.scrollIntoView(true), 200)
方案二：focus时，改变自身定位及其他定位保持位置不变，blur时恢复。
点击300ms穿透 建议方案：
1、引入fastclick cdn文件，或者npm i fastclick, 再注册fastClick实例
2、将click事件注册为touchstart事件立即执行
iOS 的 webview 中 滑动不流畅 ios5.0及以后的版本里，滑动有定义两个值，一个是auto，一个是touch
-webkit-overflow-scrolling: touch : 当手指从触摸屏上离开，会保持一段时间的滚动
-webkit-overflow-scrolling: auto: 当手指从触摸屏上离开，滚动会立即停止
在滚动容器上增加滚动touch方法，可能会导致的问题是 含有fixed的元素会随着页面一起滚动，解决方案；在
body: { ​ overflow-y: hidden; } .box { ​ overflow-y: auto; ​ -webkit-overflow-scrolling: touch; }  iOS上拉边界与下拉会出现白色空白区域 产生原因: 在 iOS 中，手指按住屏幕上下拖动，会触发 touchmove 事件。这个事件触发的对象是整个 webview 容器，容器自然会被拖动，剩下的部分会成空白</description>
    </item>
    
  </channel>
</rss>